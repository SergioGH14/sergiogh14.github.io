{"generatedAt":1730369757111,"generateTime":301,"contents":[{"_path":"/blog/about","_dir":"blog","_draft":false,"_partial":false,"_locale":"","title":"About Content v2","description":"Back home","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"about-content-v2"},"children":[{"type":"text","value":"About Content v2"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"/"},"children":[{"type":"text","value":"Back home"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:blog:about.md","_source":"content","_file":"blog/about.md","_stem":"blog/about","_extension":"md"},{"_path":"/blog","_dir":"","_draft":false,"_partial":false,"_locale":"","title":"Nuxt Content","description":"This page corresponds to the / route of your website. You can delete it or create another file in the content/ directory.","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"nuxt-content"},"children":[{"type":"text","value":"Nuxt Content"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"This page corresponds to the "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"/"}]},{"type":"text","value":" route of your website. You can delete it or create another file in the "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"content/"}]},{"type":"text","value":" directory."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Try to navigate to "},{"type":"element","tag":"a","props":{"href":"/blog/about.md"},"children":[{"type":"text","value":"/blog/about"}]},{"type":"text","value":". These 2 pages are rendered by the "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"pages/[...slug].vue"}]},{"type":"text","value":" component."}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Look at the "},{"type":"element","tag":"a","props":{"href":"https://content.nuxtjs.org/","rel":["nofollow"]},"children":[{"type":"text","value":"Content documentation"}]},{"type":"text","value":" to learn more."}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:blog:index.md","_source":"content","_file":"blog/index.md","_stem":"blog/index","_extension":"md"},{"_path":"/blog/mvp-without-db","_dir":"blog","_draft":false,"_partial":false,"_locale":"","title":"Construyendo un MVP sin BBDD","description":"Como afrontar un MVP sin decisiones precipitadas","excerpt":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"construyendo-un-mvp-sin-bbdd"},"children":[{"type":"text","value":"Construyendo un MVP sin BBDD"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Buenas prácticas de programación, código limpio, bajo acoplamiento... Todos estos conceptos son los primeros que escuchas en la universidad y podríamos englobarlos dentro del concepto "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"calidad de código."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Justo después intentas crear un producto de software y te das cuenta de que la calidad del código depende de cómo de fácil se adapte a las diferentes necesidades de un producto que está en constante evolución."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"En este post voy a intentar replicar la situación que me ayudó a entender cómo eso se puede aplicar en la vida real."}]}]},"body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"construyendo-un-mvp-sin-bbdd"},"children":[{"type":"text","value":"Construyendo un MVP sin BBDD"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Buenas prácticas de programación, código limpio, bajo acoplamiento... Todos estos conceptos son los primeros que escuchas en la universidad y podríamos englobarlos dentro del concepto "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"calidad de código."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Justo después intentas crear un producto de software y te das cuenta de que la calidad del código depende de cómo de fácil se adapte a las diferentes necesidades de un producto que está en constante evolución."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"En este post voy a intentar replicar la situación que me ayudó a entender cómo eso se puede aplicar en la vida real."}]},{"type":"element","tag":"h1","props":{"id":"mvp-eso-que-es"},"children":[{"type":"text","value":"¿MVP, eso que es?"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Un MVP (Minimum Viable Product) es una estrategia centrada en validar las hipótesis de un posible producto lo antes posible y con el menor esfuerzo. Las principales características que debemos cumplir al máximo son:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Rápido"}]},{"type":"text","value":": Cuanto antes seamos capaz de llegar al mercado, más datos vamos a poder obtener. Los datos son el motor principal de un MVP. Ellos guiarán el camino a seguir y las decisiones a tomar intentando evitar al máximo los errores y la inversión de recursos en areas que no aporten valor."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Barato"}]},{"type":"text","value":": El producto tiene que poder desecharse en caso de que no sea exitoso, ello implica que no debe de suponer una inversion de recursos grande. Esta propiedad se tiene que cumplir durante la mayor parte de vida del producto, eso significa que no solo debe de ser barato al inicio, si no que debe de evolucionar sin una inversión grande de recursos."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"MVP cicle","src":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/erejlazb86n6df0h89eq.png"},"children":[]}]},{"type":"element","tag":"h1","props":{"id":"caso-práctico"},"children":[{"type":"text","value":"Caso práctico"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Ya basta de introducciones, vayamos con un caso de ejemplo, imaginémonos la siguiente situación:"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Tenemos una aplicación bancaria que tiene una cantidad estable de usuarios mensuales. Cómo la marca está muy bien valorada, se plantea la posibilidad de añadir un carrito de compra para comprar merchandising de la marca. Con este pequeño experimento analizaremos cómo de bien puede encajar un pequeño apartado de compras dentro de la aplicación."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Una vez con la definición del MVP vamos a extraer los casos de uso que se tiene que añadir al sistema."}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Ver los productos a vender"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Añadir productos a un carrito de compra"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Ver un carrito de compra"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Pagar el contenido de un carrito de compra"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"La aplicación que existe actualmente esta construida en SpringBoot con Kotlin, usa SpringDataJPA para persistir su modelo de entidades en una base de datos relacional PostgreSQL."}]},{"type":"element","tag":"h3","props":{"id":"tablas"},"children":[{"type":"text","value":"Tablas"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Ya que el sistema esta basado en una base de datos relacional, vamos a diseñar un modelo de datos sencillos basados en tablas."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Modelo de tablas, abstracto","src":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/z800ez47w28kpgonhemd.png"},"children":[]}]},{"type":"element","tag":"h3","props":{"id":"clases"},"children":[{"type":"text","value":"Clases"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Una vez con el modelo de base de datos generado solo necesitaríamos implementar las entidades de Kotlin con JPA, esto nos ahorraría tener que implementar los CRUD de base de datos."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Modelo de clases, abstracto","src":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/a2mk1q6330pebtp5kv4y.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Ya por último exponemos los endpoints y tendremos nuestro MVP listo para ser validado."}]},{"type":"element","tag":"h3","props":{"id":"resumen"},"children":[{"type":"text","value":"Resumen"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"¿Qué queremos lograr?"}]},{"type":"text","value":"\nImplementar el MVP en el backend lo antes posible"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"¿Cómo lo hemos logrado?"}]},{"type":"text","value":"\nUsando frameworks como SpringDataJPA para evitar escribir código boilerplate."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"¿Qué hemos sacrificado?"}]},{"type":"text","value":"\nHemos usado las mismas tecnologías que se usan en el sistema actual por lo que parece que no hemos sacrificado nada."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Vision general","src":"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/omwq7yhdos7o3n2xe4o7.png"},"children":[]}]},{"type":"element","tag":"h3","props":{"id":"validando-el-mvp"},"children":[{"type":"text","value":"Validando el MVP"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Una vez con nuestra propuesta nos disponemos a validar el MVP. Una vez con los datos obtenidos recibimos esta respuesta:"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"La nueva característica ha tenido bastante éxito pero hemos detectado muchos usuarios que quieren más variedad de productos, por lo que ahora vamos a mostrar productos que nos ofrece un proveedor externo. Ademas queremos que el equipo de operaciones pueda añadir productos a mano y cambiar sus propiedades al momento para seguir consiguiendo más datos."}]}]},{"type":"element","tag":"h3","props":{"id":"esto-significa-que-el-mvp-se-ha-validado"},"children":[{"type":"text","value":"¿Esto significa que el MVP se ha validado?"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"En este tipo de desarrollos lo mas habitual es que el MVP evolucione a lo largo del tiempo hasta poder convertirse en un producto. No existe una etapa en la que después de aprender y validar se construya un nuevo proyecto desde cero. Por lo que la implementación debe evolucionar constantemente."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Analicemos cómo va a impactar estos cambios en la implementación que hemos realizado:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Añadir los productos desde un proveedor externo supone cambiar "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"totalmente"}]},{"type":"text","value":" el modelo relacional que habíamos implementado. Eso supondrá "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"cambios en el modelo de base de datos"}]},{"type":"text","value":", una "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"migración"}]},{"type":"text","value":", cambios en el "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"modelo de entidades"}]},{"type":"text","value":" y habrá que buscar una forma de unificar la obtención de productos entre la base de datos y el proveedor."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Ofrecer una forma sencilla para que el equipo de operaciones pueda añadir y editar productos sin supervision supondrá la creación de un back-office y la formación de los mismos en esta nueva herramienta."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Si comparamos el coste de implementar esta iteración con el coste de la primera implementación, se plantea un coste mucho mas alto."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"¿Pero cómo es posible, qué hemos hecho mal?"}]},{"type":"element","tag":"h2","props":{"id":"el-problema-de-las-decisiones-por-inercia"},"children":[{"type":"text","value":"El problema de las decisiones por inercia"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Todas las decisiones deben estar, en la medida de lo posible, argumentadas con datos."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Una vez empezemos a obtener datos de cómo nuestros usuarios interactúan con el sistema todo el producto puede empezar a tomar decisiones basadas en datos, y eso incluye a la implementación. Puede parecer difícil porque tendemos a pensar cosas como que necesitamos obligatoriamente una base de datos para ponernos a programar, pero eso no es cierto."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Cuanto más tiempo esperemos para tomar una decisión, mas datos tendremos que la puedan respaldar y más acertada será. Pero sobretodo hay que estar preparados para equivocarnos."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"En este caso vamos a ejemplificarlo con la elección de la base de datos, pero esta situación puede ocurrir con cualquier aspecto tecnológico, desde el sistema de colas, hasta si es mejor usar lambdas o un servidor alojado en AWS."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Sin darnos cuenta al principio de la implementación decidimos usar una BBDD relacional y el framework de JPA, además parecía una buena opción porque es lo que ya estaban usando dentro de la aplicación. Esto unido a que hemos acoplado las entidades de Kotlin a el modelo de BBDD hace que evolucionarlo sea muy costoso."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Vamos a volver a hacer la implementación pero ahora sin base de datos:"}]},{"type":"element","tag":"h1","props":{"id":"construyendo-un-mvp-sin-bbdd-1"},"children":[{"type":"text","value":"Construyendo un MVP sin BBDD"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Partimos de los mismos requisitos que antes."}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Ver los productos a vender"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Añadir productos a un carrito de compra"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Ver un carrito de compra"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Pagar el contenido de un carrito de compra"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Definimos nuestras entidades:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Cart"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Id"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Lista de productos"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Pagado o no pagado"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Product"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Id"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Nombre"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Precio"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"A cada clase le voy a añadir una función que las convertirá en un objeto sencillo con el que devolverlo en las llamadas."}]},{"type":"element","tag":"pre","props":{"className":["language-kotlin"],"code":"class Cart(id: CartId) : Entity<CartId>(id) {\n\n    private var isPaid = false\n\n    private val products = mutableListOf<Product>()\n\n    fun payCart() {\n        isPaid = true\n    }\n\n    fun addProduct(product: Product) {\n        products.add(product)\n    }\n\n    private fun getTotalPrice(): Double {\n        require(products.isNotEmpty()) { return 0.0 }\n        return products.map { it.price }.reduce { acc, product -> acc + product }\n    }\n\n    fun toData(): CartData {\n\n        return CartData(id.toString(), products, isPaid, getTotalPrice())\n    }\n\n    data class CartData(val id: String, val products: List<Product>, val isPaid: Boolean, val price: Double)\n}\n","language":"kotlin","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"class Cart(id: CartId) : Entity<CartId>(id) {\n\n    private var isPaid = false\n\n    private val products = mutableListOf<Product>()\n\n    fun payCart() {\n        isPaid = true\n    }\n\n    fun addProduct(product: Product) {\n        products.add(product)\n    }\n\n    private fun getTotalPrice(): Double {\n        require(products.isNotEmpty()) { return 0.0 }\n        return products.map { it.price }.reduce { acc, product -> acc + product }\n    }\n\n    fun toData(): CartData {\n\n        return CartData(id.toString(), products, isPaid, getTotalPrice())\n    }\n\n    data class CartData(val id: String, val products: List<Product>, val isPaid: Boolean, val price: Double)\n}\n"}]}]},{"type":"element","tag":"pre","props":{"className":["language-kotlin"],"code":"class Product(id: ProductId, val price: Double, val name: String) : Entity<ProductId>(id) {\n\n    fun toData(): ProductData {\n        return ProductData(id.toString(),price,name)\n    }\n\n    data class ProductData(val id: String, val price: Double, val name: String)\n}\n","language":"kotlin","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"class Product(id: ProductId, val price: Double, val name: String) : Entity<ProductId>(id) {\n\n    fun toData(): ProductData {\n        return ProductData(id.toString(),price,name)\n    }\n\n    data class ProductData(val id: String, val price: Double, val name: String)\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Ahora llega el momento de los casos de uso:"}]},{"type":"element","tag":"pre","props":{"className":["language-kotlin"],"code":"@GetMapping(\"/products\")\nfun getProducts(): List<Product.ProductData>? {\n    return productRepository.findAll()?.map{ it.toData()}\n}\n","language":"kotlin","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"@GetMapping(\"/products\")\nfun getProducts(): List<Product.ProductData>? {\n    return productRepository.findAll()?.map{ it.toData()}\n}\n"}]}]},{"type":"element","tag":"pre","props":{"className":["language-kotlin"],"code":"@PostMapping(\"/carts\")\nfun createCart(): String {\n    val id = CartId()\n    cartRepository.save(Cart(id))\n    return id.toString()\n}\n","language":"kotlin","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"@PostMapping(\"/carts\")\nfun createCart(): String {\n    val id = CartId()\n    cartRepository.save(Cart(id))\n    return id.toString()\n}\n"}]}]},{"type":"element","tag":"pre","props":{"className":["language-kotlin"],"code":"@GetMapping(\"/carts/{id}\")\nfun findCart(@PathVariable id: String): Cart.CartData? {\n    return cartRepository.find(CartId(id))?.toData()\n}\n","language":"kotlin","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"@GetMapping(\"/carts/{id}\")\nfun findCart(@PathVariable id: String): Cart.CartData? {\n    return cartRepository.find(CartId(id))?.toData()\n}\n"}]}]},{"type":"element","tag":"pre","props":{"className":["language-kotlin"],"code":"@PutMapping(\"/carts/{id}\")\nfun addProductsToCart(@RequestBody products: List<String>, @PathVariable id: String){\n    val cart = cartRepository.find(CartId(id))\nrequire(cart!=null)\nrequire(products.all{productRepository.find(ProductId(it)) != null})\n    products.forEach{cart.addProduct(productRepository.find(ProductId(it))!!)}\ncartRepository.save(cart)\n}\n","language":"kotlin","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"@PutMapping(\"/carts/{id}\")\nfun addProductsToCart(@RequestBody products: List<String>, @PathVariable id: String){\n    val cart = cartRepository.find(CartId(id))\nrequire(cart!=null)\nrequire(products.all{productRepository.find(ProductId(it)) != null})\n    products.forEach{cart.addProduct(productRepository.find(ProductId(it))!!)}\ncartRepository.save(cart)\n}\n"}]}]},{"type":"element","tag":"pre","props":{"className":["language-kotlin"],"code":"@PostMapping(\"/carts/{id}\")\nfun payCart(@PathVariable id: String){\n    val cart = cartRepository.find(CartId(id))\nrequire(cart!=null)\n    cart.payCart()\n}\n","language":"kotlin","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"@PostMapping(\"/carts/{id}\")\nfun payCart(@PathVariable id: String){\n    val cart = cartRepository.find(CartId(id))\nrequire(cart!=null)\n    cart.payCart()\n}\n"}]}]},{"type":"element","tag":"h2","props":{"id":"y-la-bbdd"},"children":[{"type":"text","value":"¿Y la BBDD?"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Cómo se ve en el código anterior estamos usando repositorios, pero ninguna BBDD. Para poder validar que todo esto funcione correctamente estamos usando repositorios en memoria."}]},{"type":"element","tag":"pre","props":{"className":["language-kotlin"],"code":"abstract class InMemoryRepository<E: Entity<I>, I: Id> : Repository<E, I> {\n\n    protected val database =mutableMapOf<I,E>()\n\n    override fun find(id: I): E? {\n        return database[id]\n    }\n\n    override fun findAll(): List<E>? {\n        return database.values.toList()\n    }\n\n    override fun save(data: E) {\n        database[data.id] = data\n    }\n\n    override fun delete(id: I) {\n        database.remove(id)\n    }\n\n    fun clear(){\n        database.clear()\n    }\n}\n","language":"kotlin","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"abstract class InMemoryRepository<E: Entity<I>, I: Id> : Repository<E, I> {\n\n    protected val database =mutableMapOf<I,E>()\n\n    override fun find(id: I): E? {\n        return database[id]\n    }\n\n    override fun findAll(): List<E>? {\n        return database.values.toList()\n    }\n\n    override fun save(data: E) {\n        database[data.id] = data\n    }\n\n    override fun delete(id: I) {\n        database.remove(id)\n    }\n\n    fun clear(){\n        database.clear()\n    }\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Todo este ejemplo esta preparado con algunas definiciones básicas como Entity, Id, y Repository. Pero estas no son necesarias, aunque en caso de que quieres usarlas en el "},{"type":"element","tag":"a","props":{"href":"https://github.com/SergioGH14/cart-mvp","rel":["nofollow"]},"children":[{"type":"text","value":"código"}]},{"type":"text","value":" tienes más detalle."}]},{"type":"element","tag":"h2","props":{"id":"y-ahora-qué"},"children":[{"type":"text","value":"¿Y ahora qué?"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Perfecto, ya tenemos nuestro MVP sin BBDD ¿y en qué nos beneficia esto?"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Todo dependerá del tipo de validación que vayamos a hacer ahora:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Si lo vamos a hacer una demo pequeña y para un grupo de usuarios reducido la solución que hemos presentado nos serviría"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Si queremos añadir persistencia tenemos todas las opciones disponibles, solo tenemos que implementar un repositorio para la que queramos evaluar.\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"InMemoryRepository"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"MongoRepository"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"PostgreSQLRepository"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"GoogleSheetsRepository"}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Pero analicemos que hemos conseguido realmente:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Más velocidad: Sin configurar absolutamente nada de BBDD podemos empezar a validar nuestro MVP"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Menos acoplamiento: Ahora el código no depende de ninguna tecnología en concreto, dentro de cada repository podemos usar la tecnología que queramos."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Mejorar los tests: Teniendo los repositorios en memoria ya no se tiene que mockear los repositorios, ni levantar la aplicación para hacer pruebas sencillas"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Repositorios multi-repo: Uno de los problemas que surgían al intentar evolucionar el MVP era una entidad te podia llegar desde BBDD o desde una API. Ahora podemos implementar un repo que se inyecte esos dos repositorios sin que nada de la implementación cambie."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Cambios progresivos de modelo: Al no tener la BBDD directamente mapeada en el código podemos ir aplicando los cambios de modelo de forma progresiva."}]}]},{"type":"element","tag":"h2","props":{"id":"evolucionando-el-nuevo-mvp"},"children":[{"type":"text","value":"Evolucionando el nuevo MVP"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"No podíamos acabar sin analizar cómo afectarían los cambios anteriores a nuestro nuevo MVP."}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Mostrar productos de un tercero"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Cómo hemos visto anteriormente podríamos implementar un multi-repo en el que implementar la lógica de las dos formas de acceder a los productos sin afectar a la estabilidad del sistema."}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Ofrecer una solución para que operaciones pueda añadir nuevos productos"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"En este caso una solución podría ser crear de forma temporal los registros de los productos en un google sheets. Seria una forma rápida y barata de obtener la información y validar el MVP. Y de nuevo seria implementar un repositorio."}]}]}]}]},{"type":"element","tag":"h1","props":{"id":"conclusiones"},"children":[{"type":"text","value":"Conclusiones"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Lo primero de todo me gustaría matizar que no significa que siempre que se construya un MVP debería estar prohibido añadirle una base de datos. En este ejercicio intento demostrar que para construir un primer MVP se necesita muy poco y qué constantemente abusamos de frameworks y tecnologías que consideramos erróneamente esenciales."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Por otro lado recalcar la importancia de la independencia de las diferentes capas de la aplicación. Gran parte de los problemas que surgieron con el ejemplo de JPA se deben a usar las entidades del propio framework como entidades de dominio algo que condiciona todo el modelo de dominio al modelo de base de datos, algo que tal y como vimos dificulta su evolución"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Por tanto y resumiendo; no hacen falta frameworks gigantes para invertir menos tiempo programando y mantener la independencia del código respecto a las tecnologías que usemos nos dará más opciones a la hora de evolucionar el producto que estemos desarrollando."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Muchas gracias por leerme, "},{"type":"element","tag":"a","props":{"href":"https://github.com/SergioGH14/cart-mvp","rel":["nofollow"]},"children":[{"type":"text","value":"aquí"}]},{"type":"text","value":" te dejo todo el código que aparece en el artículo."}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"tablas","depth":3,"text":"Tablas"},{"id":"clases","depth":3,"text":"Clases"},{"id":"resumen","depth":3,"text":"Resumen"},{"id":"validando-el-mvp","depth":3,"text":"Validando el MVP"},{"id":"esto-significa-que-el-mvp-se-ha-validado","depth":3,"text":"¿Esto significa que el MVP se ha validado?"},{"id":"el-problema-de-las-decisiones-por-inercia","depth":2,"text":"El problema de las decisiones por inercia"},{"id":"y-la-bbdd","depth":2,"text":"¿Y la BBDD?"},{"id":"y-ahora-qué","depth":2,"text":"¿Y ahora qué?"},{"id":"evolucionando-el-nuevo-mvp","depth":2,"text":"Evolucionando el nuevo MVP"}]}},"_type":"markdown","_id":"content:blog:mvp-without-db.md","_source":"content","_file":"blog/mvp-without-db.md","_stem":"blog/mvp-without-db","_extension":"md"}],"navigation":[{"title":"Nuxt Content","_path":"/blog","children":[{"title":"About Content v2","_path":"/blog/about"},{"title":"Nuxt Content","_path":"/blog"},{"title":"Construyendo un MVP sin BBDD","_path":"/blog/mvp-without-db"}]}]}